#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{to_json_binary, Addr,Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult, Uint128};
// use cw2::set_contract_version;

use crate::error::ContractError;
use crate::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
use crate::state::{GameSession, State, STATE,SESSIONS};

/*
// version info for migration info
const CONTRACT_NAME: &str = "crates.io:gambling_contract";
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");
*/

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(deps: DepsMut, _env: Env, info: MessageInfo, _msg: InstantiateMsg) -> StdResult<Response> {
    let state = State {
        owner: info.sender.clone(),  
    };

    STATE.save(deps.storage, &state)?;
    Ok(Response::default().add_attribute("action", "instantiated successfully"))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::PlaceBet { amount, player,mines } => place_bet(deps, amount,player,mines,info.sender),
        ExecuteMsg::ResolveGame { player, number } => resolve_game(deps, player, info.sender, number),
        ExecuteMsg::ClaimWinnings { player } => claim_winnings(deps, player, info.sender),
    }
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::GetActiveSessions {} => to_json_binary(&query_active_sessions(deps)?),
        QueryMsg::GetPlayerSession { player } => to_json_binary(&query_player_session(deps, player)?),
    }
}

// Ensure only the owner (platform) can call this function
fn check_owner(state: &State, sender: &Addr) -> StdResult<()> {
    if state.owner != sender {
        return Err(cosmwasm_std::StdError::generic_err("Unauthorized: only the owner can perform this action"));
    }
    Ok(())
}

//Amount to be sent in 8 decimals
fn place_bet(
    deps: DepsMut,
    amount: Uint128,
    player: Addr,
    mines: Uint128,
    sender: Addr,
) -> Result<Response, ContractError> {
    let state = STATE.load(deps.storage)?;
    check_owner(&state, &sender)?;

    let session = GameSession {
        player: player.clone(),
        bet_amount: amount,
        mines: mines,
        probability: Uint128::new(100000000),
        wins: Uint128::new(0),
        multiplier: Uint128::new(100000000), //Upto 8 decimals of precision
        is_active: true,
        is_winner: false,
    };

    // Insert session into the map with the player's address as the key
    SESSIONS.save(deps.storage, player.to_string(), &session)?;
    Ok(Response::new().add_attribute("action", "bet_placed"))
}

fn resolve_game(
    deps: DepsMut,
    player: Addr,
    sender: Addr,
    number: Uint128  // Random number generated by the player
) -> Result<Response, ContractError> {
    let state = STATE.load(deps.storage)?;

    check_owner(&state, &sender)?;

    if let Some(mut session) = SESSIONS.may_load(deps.storage, player.to_string())? {
        if session.is_active {
            let random_number = number.u128();

            let current_probability = (25 - session.wins.u128() - session.mines.u128()) as f64 / 25.0;

            let probability = (session.probability.u128() as f64 / 100000000.0) * current_probability;
            
            let mut multiplier: f64 = 1.0 / probability;
            multiplier = multiplier * 100000000.0; // Converting to 8 decimals of precision

            if multiplier > 5000000.0 * 100000000.0 {
                multiplier = 5000000.0 * 100000000.0; // Capping multiplier to 5 million...
            }

            // numbers ranging between 1 and 10 000 000
            if (random_number as f64 / 100000000.0) < current_probability {
                session.is_winner = true;
                session.multiplier = Uint128::from(multiplier as u128);
                session.wins += Uint128::new(1);
                session.probability = Uint128::from((probability * 100000000.0) as u128);
            } else {
                // Player loses, claim winnings 
                session.is_winner = false;
            }

            let is_winner = session.is_winner;

            if !is_winner {
                SESSIONS.remove(deps.storage, player.to_string());
            } else {
                SESSIONS.save(deps.storage, player.to_string(), &session)?;
            }

            return Ok(
                Response::new()
                    .add_attribute("action", "game_resolved")
                    .add_attribute("result", if is_winner { "win" } else { "loss" })
            );
        }
    }
    Ok(Response::new().add_attribute("action", "no_active_session_found_for_the_user"))
}

fn claim_winnings(
    deps: DepsMut,
    player: Addr,
    sender: Addr,
) -> Result<Response, ContractError> {
    let state = STATE.load(deps.storage)?;

    check_owner(&state, &sender)?;

    if let Some(session) = SESSIONS.may_load(deps.storage, player.to_string())? {
        if session.is_active && session.is_winner { 
            // Remove the session from the map after making the payment

            let payout = session.bet_amount.u128() as f64 * (session.multiplier.u128() as f64 / 100000000.0);
            SESSIONS.remove(deps.storage, player.to_string());

            return Ok(
                Response::new().add_attribute("action", "claim_winnings").add_attribute("amount", payout.to_string())
            );
        } 
    }

    Ok(Response::new().add_attribute("action", "no active session found for the user"))
}

fn query_active_sessions(deps: Deps) -> StdResult<Vec<GameSession>> {
    let active_sessions: Vec<GameSession> = SESSIONS
        .range(deps.storage, None, None, cosmwasm_std::Order::Ascending)
        .filter_map(|item| item.ok())
        .map(|(_, session)| session)
        .filter(|session| session.is_active)
        .collect();
    return Ok(active_sessions)
}

fn query_player_session(deps: Deps, player: Addr) -> StdResult<GameSession> {
    if let Some(session) = SESSIONS.may_load(deps.storage, player.to_string())? {
        return Ok(session)
    } else {
        return Err(cosmwasm_std::StdError::generic_err("No active session found for the user"))
    }
}
